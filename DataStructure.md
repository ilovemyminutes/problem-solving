# 자료구조

- 자료: 데이터 - 저장공간(memory)과 (읽기, 쓰기, 삽입, 삭제, 탐색) 등의 연산이 지원되어야 함
  - 위 요소들이 포함된 것: 자료구조

- 알고리즘: 자료를 입력해서 유한한 횟수의 연산을 활용해서 정답을 출력하는 것


## 시간복잡도
* 자료구조 및 알고리즘: 코드를 바탕으로 동작하기 때문에 하드웨어 성능마다 상이할 수 있음
  * 알고리즘 성능을 평가하기 위해 가상머신, 가상언어, 가상코드를 약속해서 알고리즘 간 성능 비교
  * 가상머신(Virtual Machine): Turing Maching (폰노이만) - RAM(Random Access Machine)
    * RAM: 다음으로 구성된 가상머신
      * CPU
      * Memory
      * 기본연산: '단위시간'에 수행되는 연산들의 모음
        * 배정 연산
        * 대입 연산
        * 복사 연산
        * 사칙 연산 (`+, -, *, /`)
        * 비교 연산
        * 논리 연산 (AND, OR, NOT)
        * 비트 연산
  * 가상언어 - 다음을 명시할 수 있는 언어
    * 배정, 산술, 비교, 논리, bit-논리 등 기본연산 표현
    * 조건문: if, if/else, if/elif/else
    * 반복문: for, while
    * 함수: 정의, 호출, 리턴 등
  * 가상코드(pseudo code) - 느슨하게 코드에 대한 설명을 논리적으로 해내는 것

* 시간복잡도
  * Worstcase input에 대한 기본 연산 횟수를 측정 (worstcase time complexity)
    * 최악의 입력에 대한 기본연산 횟수
  * 알고리즘의 수행시간

* Big-O 표기법
  * 알고리즘의 수행시간: 최악의 경우의 입력에 대한 기본연산횟수
  * Big-O: 수행시간을 결정하는 최고차항만으로 간단히 표기. 즉, 연산량의 주된 증가율에만 초점을 맞춘 표기법
    * 최고차항만 남긴다
    * 최고차항 계수는 생략
    * $O(\cdot)$ 꼴
      ```shell
      Case1(n) = 2n - 1 => O(N)
      Case2(n) = 4n + 1 => O(N) # 디테일하게는 Case1보다 구린 알고리즘이지만 연산 증가율의 관점에서 동일하다고 볼 수 있음
      Case3(n) = n^2 + 2n + 7 => O(N^2)
      ```

## 배열(array) vs. 리스트(list) - *가장 기본적이면서 중요한 자료 구조*
* 가장 기본적인 sequential 자료구조



## Queue

- FIFO(선입선출) 구조
- 선형 구조
- Enqueue: 큐 맨 뒤에 요소를 추가
- Dequeue: 큐 맨 앞쪽에 요소를 삭제
- Peek: front에 위치한 데이터를 읽음
- Front: 큐의 맨 앞의 위치(인덱스)
- Rear: 큐의 맨 뒤의 위치(인덱스)



## Tree

- 비선형 구조
- 단순히 값을 저장하는 용도보다는 효율적인 탐색 혹은 정렬을 위해 사용
- Node: 트리의 구성 요소
- Edge: 노드와 노드를 연결하는 선
- Root node: 트리 구조에서 최상위에 존재하는 노드
- Terminal node(=leaf node, 단말 노드): 밑으로 또 다른 노드가 존재하지 않는 마지막 노드
- Sub-tree: 어떠한 트리에 포함되는 트리
- Level: 트리의 각 층에 매기는 숫자
- Height: 트리 최고 레벨

#### 이진 트리(Binary tree)

- 각 노드가 최대 2개의 자식 노드를 가진 트리 구조
- 루트 노드를 중심으로 나뉘는 2개의 서브 트리가 이진 트리
- 서브 트리의 모든 서브 트리도 이진 트리
- 주어진 값 혹은 이보다 작거나 큰 값들을 평균 `O(logn)`의 시간 복잡도로 찾을 수 있음
- 이진 트리의 한 종류인 힙(`heap`)을 사용한 힙 정렬(`heap`)은 `O(nlogn)`의 시간복잡도를 가짐

##### 포화 이진 트리(Full binary tree): [?]

##### 완전 이진 트리(Complete binary tree): [?]

##### 이진 탐색 트리

- 이진 트리의 특수 케이스 중 하나
- 이진 트리 중 다음을 만족하는 트리는 이진 탐색 트리
  1. 모든 노드에 대해 왼쪽 자식 노드들의 값이 현재 노드 값보다 작음
  2. 오른쪽 자식 노드들의 값이 현재 노드의 값보다 큼
- 오른쪽으로는 큰 값만 주르륵, 왼쪽으로는 작은 값만 주르륵 들어가는 느낌([참고](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99AD154D5C5C50D932))
- 위의 룰이 설정되어 있으니, 원하는 값을 탐색할 때 저 룰을 바탕으로 빠르게 탐색할 수 있는 셈


## 메모리 구조
* 운영체제는 프로그램의 정보를 메모리에 로드하여 프로그램을 실행함
* 프로그램 실행 동안 메모리 공간은 **코드, 데이터, 힙, 스택 영역**의 4가지로 구성
  * 각 영역을 **세그먼트(segment)**라고 부름

### 코드 영역
* 실행할 프로그램의 코드가 저장. 텍스트 영역으로 부르기도 함
* 코드 영역의 명령을 하나씩 가져와 CPU가 처리하게 됨
* 프로그램이 시작되어 종료될 때까지 메모리에 남아있음

### 데이터 영역
* 전역 변수와 정적 변수가 저장되는 영역
* 프로그램의 시작과 함께 할당되어 프로그램이 종료되면 소멸

### 스택 영역
* 함수 호출 시 생성되는 지역변수/매개변수가 저장되는 영역. 함수 호출이 완료되면 사라짐
  * 스택 영역에 저장되는 함수의 호출 정보를 **스택 프레임**이라고 함
* 컴파일 타임(Compile time)에 크기가 결정 됨
* LIFO(후입선출) 방식 - 가장 나중에 들어 온 데이터가 가장 먼저 인출 됨 => 스택 영역이 높은 메모리 주소에서 낮은 메모리 주소 방향으로 할당되기 때문
  * push로 데이터를 저장하고 pop으로 데이터를 인출

### 힙 영역
* 프로그래머가 직접 메모리 공간을 할당, 해제하는 영역
* 런 타임(Run time)에 크기가 결정 됨
* (C++) `malloc()`, `new` operator를 통해 메모리를 할당, `free()`, `delete` operator를 통해 메모리를 해제
* FIFO(선입선출) 방식 - 가장 먼저 들어 온 데이터가 가장 먼저 인출됨 => 힙 영역이 낮은 메모리 주소에서 높은 메모리 주소 방향으로 할당되기 때문

### 오버플로우
* 한정된 메모리 공간이 부족해 메로리 내 데이터가 넘쳐 흐르는 현상
  * 힙 영역은 낮은 메모리 주소에서 낮은 메모리 주소의 방향으로 메모리를 할당하고,
  * 스택 영역은 높은 메모리 주소에서 낮은 메모리 주소의 방향으로 메모리를 할당하는데,
  * 모든 데이터를 할당하기에 메모리가 충분하지 않으면 서로의 영역을 침범하게 됨 => ***'오버플로우'***
* 힙 오버플로우: 힙 영역이 스택 영역을 침범하는 경우
* 스택 오버플로우: 스택 영역이 힙 영역을 침범하는 경우

### 컴파일 타임 vs. 런 타임
* 런 타임 (Run time)
  * 컴파일 과정을 마친 프로그램이 사용자에 의해 실행되는 시간 또는 때(time)
  * 런 타임 에러 (Run time error): 컴파일이 완료되어 프로그램에 실행 중임에도, 의도치 않은 예외 상황으로 프로그램 실행 중에 발생하는 오류
    * zero-division error, null, OOM error
* 컴파일 타임 (Compile time)
  * 개발자(프로그래머 또는 사용자)에 의해 개발언어로 소스코드가 작성된 뒤, 해당 코드가 컴퓨터가 인식할 수 있는 기계어 코드로 변환되어 실횅 가능한 프로그램에 되는 과정
  * 컴파일 타임 에러 (Compile time error): 컴파일 타임 중 발생하는 오류 (Syntax error, 파일 참조 오류 등)
    * Syntax Error
    * Type check error


## ETC

###### 선형구조

- 자료를 구성하고 있는 데이터들이 순차적으로 나열됨	
- 자료를 저장하고 꺼내는 것에 초점

##### 비선형 구조

- 데이터가 계층적 형태 또는 그래프 형태로 구성됨
- 표현에 초점



### References

- [자료구조: 큐(Queue) 이해하기](https://monsieursongsong.tistory.com/5)
- [위키피디아: 이진트리](https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%8A%B8%EB%A6%AC)
- [파이썬을 이용해서 이진 탐색 트리 구현하기](https://geonlee.tistory.com/72)